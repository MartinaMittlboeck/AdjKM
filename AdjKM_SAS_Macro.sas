**************************************************************************************************;
* AdjKM-SAS-Macro                                                                                *;
* Author: Martina Mittlboeck, Medical University of Vienna, Austria                              *;
* Version July 2023 ((includes patients at risk in survival plot)                                *;
**************************************************************************************************;
*                                                                                                *;
* data ......... name of input data set                                                          *;
*                                                                                                *;
* td_time ...... name of variable containing time until donor identification.                    *;
*                Values between zero and min(tsearch, event_time) indicate an available donor.   *;
*                In case of an unavailable donor set td_time to a missing or negative value.     *;
*                                                                                                *;
* event_time ... name of outcome related survival time variable (e.g. overall survival)          *;
*                                                                                                *;
* event_status . name of outcome related survival status, zero is assumed to indicate censoring  *;
*                                                                                                *;
* tsearch ...... maximum donor search time                                                       *;
*                                                                                                *;
* tstar ........ time point for calculation of survival probabilities and cHR                    *;
*                                                                                                *;
* atrisk ....... state time points to show patients at risk in the survival plot                 *;
*                e.g. %str(0 to 10 by 1)                                                         *;
*                                                                                                *;
* alpha ........ two-sided significance level, that is, 1-alpha is a 2-sided confidence level    *;
*                                                                                                *;
* Boot_method   .. bootstrap methods for two-sided confidence intervals:     			 *;
*                NO   - no Bootstrap (only naive)   	                                         *;
*                WALD - naive and Bootstrap-Wald                                                 *;
*                ALL  - naive, Bootstrap-Wald, percentile, BC and BCa                            *;
*				     BC: bias corrected percentile method                        *;
*				     BCa: bias corrected and accelerated percentile method       *;
*                Default: NO                                                                     *;
*												 *;
* boot_rep ..... number of boostrap replicates 							 *;
*				 (recommended 200 for Wald boostrap and 2000 for percentile, BC and BCa methods) *;
*                Default: 0 for no                                                               *;
*                         200 for Wald                                                           *;
*                         2000 for all                                                           *;
*                                                                                                *;
* out_data ...... (library and) prefix of the name of the two output data sets                   *;
*                 which are distinguished by the postfixes "_TIME" and "_SURV":                  *;
*                 _TIME - for individual survival data and weights with                          *;
*                         _td_      - new variable indicating group membership	         	 *;
*                         _M_weight - new weight variable                                        *;
*                 _SURV - for survival estimates (standard SAS-output from PROC LIFETEST         *;
*                                                                                                *;
**************************************************************************************************;


%macro AdjKM(data, td_time, event_time, event_status, tsearch, tstar, atrisk, alpha, boot_method, boot_rep, out_data);
options nonotes nofmterr;
ods listing close;
ods select none;
%if &boot_method eq %then %do; %let boot_method=NO; %let boot_rep=0; %end;
%if %upcase(&Boot_method)=NO %then %let boot_rep=0;
%if %upcase(&Boot_method)=WALD and (&boot_rep eq or &boot_rep<=0) %then %let boot_rep=200;
%if %upcase(&Boot_method)=ALL  and (&boot_rep eq or &boot_rep<=0) %then %let boot_rep=2000;
%let _count_=1;
%let _tstar_valid=;
%let _tstar_=%qscan(&tstar,&_count_,%str( ));
%do %while(&_tstar_ ne);
	%if &tsearch <= &_tstar_ %then %let _tstar_valid= &_tstar_valid. &_tstar_.; 
	%else %do;
		%put remark=%str(TSEARCH= &tsearch IS HIGHER THAN TSTAR= &_tstar_, SO THAT TSTAR=&_tstar_ IS NOT CONSIDERED);
	%end;
	%let _count_=%eval(&_count_+1);
	%let _tstar_=%qscan(&tstar,&_count_,%str( ));
%end;

%let _count_=%eval(&_count_-1);
%put FINAL TSTAR= &_tstar_valid (only times are valid that are equal or higher than TSEARCH= &tsearch;

%let alpha_low=%sysevalf(100*&alpha/2);
%let alpha_upp=%sysevalf(100*(1-&alpha/2));

proc format;
	value _donf_ 0='no donor available' 1='donor available' -1='donor search ceased'; 
run;
data _data_all; 
	set &data END=_nrobs_;
	* calculate time-dependent time and status;
	if 0<=&td_time<=min(&event_time,&tsearch) then do;
		_time_td=&td_time;
		_td_event=1;
		_donor=1;
	end;
	else do;
		_time_td=min(&event_time,&tsearch);
		_td_event=0;
		if &event_time<&tsearch then _donor=-1;
		else _donor=0;
	end;
	* unique numbering of patients; 
	_pat_id=_n_;
	* determination of effective sample size;
	if _nrobs_ then do;
		call symputx('samplesize',_pat_id);
	end;
	keep &event_time &event_status &td_time _time_td _td_event _donor _pat_id;
run;

%if %upcase(&Boot_method)^=NO %then %do;
	proc sort data=_data_all; by _pat_id; run;
	proc surveyselect data=_data_all out=boot(compress=binary drop=NumberHits)
 	    seed=582 method=urs samprate=1 rep=&boot_rep outhits noprint;
	run;
	proc sort data=boot(compress=binary); by replicate; run;
	data boot(compress=binary); set boot;
		by replicate _pat_id;
		_source_='boot    ';
		if first.replicate then _pat_rep=0;
		_pat_rep+1;
		rename replicate=_replicate_;
	run;
%end;

*************** jackknife for BCa **********************;
%if %upcase(&Boot_method)=ALL %then %do;
	data BCa_jack(compress=binary);
		set _data_all(keep=_pat_id &event_time &event_status &td_time _time_td _td_event _donor);
		_source_='jack    ';
		do _replicate_=1 to &samplesize; 
				if _replicate_ ne _pat_id then output; * leave the ith patient out - patient is total patient number; 
		end;
	run;
	proc sort data=BCa_jack; by _source_ _replicate_; run;
%end;

data _data_all(compress=binary); 
	set _data_all(in=o) 
		%if %upcase(&boot_method)^=NO %then boot; 
		%if %upcase(&boot_method)=ALL %then BCa_jack(in=j);  ;
	%if %upcase(&boot_method)=ALL %then %do;
		if j then _pat_rep=_pat_id;
	%end;
	if o then do; 
		_replicate_=0; 
		_source_='original';
		_pat_rep=_pat_id;
	end;
run;
proc sort data=_data_all; by _source_ _replicate_ _pat_rep; run;

* calculate survival probabilities for M-weights for individual patients;
ods output ProductLimitEstimates=_s_bmt_(drop=stratum failure stderr failed left); 
proc lifetest data=_data_all;
	by _source_ _replicate_;
	time _time_td*_td_event(0);
	id _pat_rep;
run;
data _s_bmt _s_bmt_tsearch; 
	set _s_bmt_ END=tsearch_time;
	by _source_ _replicate_ _time_td;
	retain s_urv;
	if survival^=. then _surv_td=survival;
	else                _surv_td=s_urv;
	s_urv=_surv_td;
	if _pat_rep=. then delete;
	if last._replicate_ then output _s_bmt_tsearch;
	output _s_bmt;
	drop censor survival s_urv;
run;

proc sort data=_data_all;  by _source_ _replicate_ _pat_rep; run;
proc sort data=_s_bmt;     by _source_ _replicate_ _pat_rep; run;
proc sort data=_s_bmt_tsearch; by _source_ _replicate_; run;
data _scen_; 
	merge _data_all(in=a) _s_bmt(in=t drop=_time_td);
	by _source_ _replicate_ _pat_rep;
run;
data _scen_; 
	merge _scen_ _s_bmt_tsearch(rename=(_surv_td=_surv_tsearch) drop=_time_td _pat_rep); 
	by _source_ _replicate_;
run;

data result_out; set _scen_(in=a); 
	if 0<=&td_time<=min(&event_time,&tsearch) then do; *donor available and identified;
		_td_=1;
		_M_weight=1; 
		output;
	end;
	else if &event_time>=&tsearch then do; *no donor available;
		_td_=0;
		_M_weight=1; 
		output;
	end;
	else if &event_time<&tsearch then do;
		if abs(_surv_tsearch-_surv_td)<0.00000001 then do;
			_M_weight=1;
			_td_=0;
			output;
		end;
		else do;
			_M_weight=_surv_tsearch/_surv_td;
			_td_=0;
			output;
			_M_weight=1-_surv_tsearch/_surv_td; 
			_td_=1;
			output;
		end;
	end;
	drop _surv_td _surv_tsearch;
run;

proc lifetest data=result_out timelist=&_tstar_valid outsurv=_surv_prob_rep reduceout stderr;
	by _source_ _replicate_;
	time &event_time*&event_status(0);
	weight _M_weight;
	strata _td_ ;* / test=all;
run;
	
* tanspose to get survival estimates of groups side-by-side ;
proc sort data=_surv_prob_rep; by _source_ timelist _replicate_ _td_; run;
proc transpose data=_surv_prob_rep out=_surv_prob_rep_t; by _source_ timelist _replicate_; id _td_; var survival; run;
data _surv_prob_rep_test; 
	set _surv_prob_rep_t;
	diff= log(-log(_1))-log(-log(_0));
	cHR=exp(diff);
	if _source_='original' and _replicate_=0 then call symputx('log_log_diff_orig',diff);
run;
* variance estimate of bootstrap differences for bootstrap Wald p-value and CIs ;
%if %upcase(&boot_method)^=NO %then %do;
	proc means data=_surv_prob_rep_test noprint;
		where _source_='boot' and _replicate_>0;
		by _source_ timelist;
		var diff;
		output out=boot_var_diff(keep=_source_ timelist var_boot nr_boot) VAR=var_boot N=nr_boot out;
	run;
	proc sort data=Boot_var_diff; by timelist; run;
%end;
* mean of jackknife samples to estimate a for BCa Bootstrap CI ;
%if %upcase(&boot_method)=ALL %then %do;
	proc means data=_surv_prob_rep_test noprint;
		where _source_='jack' and _replicate_>0;
		by _source_ timelist;
		var diff;
		output out=jack_mean_diff(keep=_source_ timelist mean_jack nr_jack) mean=mean_jack N=nr_jack out;
	run;
	* estimate a for BCa Bootstrap CI ;
	data BCA_jack_a; 
		merge _surv_prob_rep_test(where=(_source_='jack')) jack_mean_diff  END=_last_; 
		by _source_ timelist;
		if first.timelist then do; zaehler=0; nenner=0; end;
		zaehler=zaehler+(diff-mean_jack)**3;
		nenner=nenner+(diff-mean_jack)**2;
		retain zaehler nenner;
		if _last_ then do;
			a_hat=zaehler/(6*(nenner**1.5));
			call symputx('BCa_a_hat',a_hat);
		end;
	run;

	*** estimate for bias-corrected(BC) bootstrap solution ***;
	data bc; set _surv_prob_rep_test(where=(_source_='boot' and _replicate_>0)) end=_BC_;
		if _n_=1 then p_0_BC=0;                       
		if diff<=&log_log_diff_orig then p_0_BC=p_0_BC+1;
		retain p_0_BC; 
		if _BC_ then do;
			p0_BC  =p_0_BC/&boot_rep;
			z0_BC  =quantile('NORMAL',p0_BC);
			z_alpha=quantile('NORMAL',(&alpha_upp/100));
			CDF_BC_upp=100*CDF('NORMAL', (2*z0_BC + z_alpha));
			CDF_BC_low=100*CDF('NORMAL', (2*z0_BC - z_alpha));
			CDF_BCa_upp=100*CDF('NORMAL', (z0_BC + (z0_BC + z_alpha) / (1 - &BCa_a_hat*(z0_BC + z_alpha))));
			CDF_BCa_low=100*CDF('NORMAL', (z0_BC + (z0_BC - z_alpha) / (1 - &BCa_a_hat*(z0_BC - z_alpha))));
			call symputx('BC_percent_low',CDF_BC_low);
			call symputx('BC_percent_upp',CDF_BC_upp);
			call symputx('BCa_percent_low',CDF_BCa_low);
			call symputx('BCa_percent_upp',CDF_BCa_upp);
		end;
	run;

	proc univariate data=_surv_prob_rep_test noprint;
		by timelist;
		where _source_='boot' and _replicate_>0;
		var diff; 
		output out=Boot_CI_percent pctlpre=CI_per_    pctlname=low upp    pctlpts=&alpha_low, &alpha_upp; 
		output out=Boot_CI_BC      pctlpre=CI_BC__    pctlname=low upp    pctlpts=&BC_percent_low, &BC_percent_upp;
		output out=Boot_CI_BCa     pctlpre=CI_BCa_    pctlname=low upp    pctlpts=&BCa_percent_low, &BCa_percent_upp;
	run;
	proc print data=Boot_CI_percent; run;
	proc print data=Boot_CI_BC; run;
	proc print data=Boot_CI_BCa; run;
%end;
proc sort data=_surv_prob_rep; by timelist _replicate_ _td_; run;
proc transpose data=_surv_prob_rep(where=(_replicate_=0)) out=_surv_prob_t;  by timelist _replicate_ _td_; var survival SDF_STDERR; run;
proc transpose data=_surv_prob_t out=_surv_prob_tt prefix=S_; by timelist; copy _td_ col1; var col1; run;

data _surv_prob_test2;
	label TIMELIST='t*' cHR='cHR' CI_low_cHR='lower CI for cHR' CI_upp_cHR='upper CI for cHR' test='chi-square test statistic' 
		prob='p-value' boot='number of bootstraps';
	set _surv_prob_tt(where=(S_1^=.) in=n) 
			%if %upcase(&boot_method)^=NO %then boot_var_diff (in=w);
			%if %upcase(&boot_method)=ALL %then 
				Boot_CI_percent(rename=(CI_per_low=CI_low  CI_per_upp=CI_upp) in=p1) 
				Boot_CI_BC(rename=(CI_BC__low=CI_low  CI_BC__upp=CI_upp) in=p2) 
				Boot_CI_BCa(rename=(CI_BCa_low=CI_low CI_BCa_upp=CI_upp) in=p3);  ;
	if n then do;
		diff= log(-log(S_3))-log(-log(S_1));
		cHR=exp(diff);
		_var_=( (S_2**2/((S_1*log(S_1))**2)) + (S_4**2/((S_3*log(S_3))**2)) );
		boot=.;
		type='naive               ';
	end;
	else do; 
		%if %upcase(&boot_method)^=NO %then %do;
			if w then do; 
				_var_=var_boot;
				type='Variance Bootstrap  ';
			end; 
		%end;
		%if %upcase(&boot_method)=ALL %then %do;
			if p1 then type='Percentile Bootstrap';
			if p2 then type='BC Bootstrap';
			if p3 then type='BCa Bootstrap'; 
		%end;
		boot=&boot_rep;
	end;
	retain diff cHR;
	if n %if %upcase(&boot_Method)^=NO %then or w ; then do;
		test=(diff**2)/_var_;
		prob=1-CDF('CHISQUARE', test, 1);
		CI_low = diff - quantile('NORMAL',(1-(&alpha/2))) * sqrt(_var_);
		CI_upp = diff + quantile('NORMAL',(1-(&alpha/2))) * sqrt(_var_);
	end;
	CI_low_cHR=exp(CI_low);
	CI_upp_cHR=exp(CI_upp);
	keep timelist cHR CI_low_cHR CI_upp_cHR test prob boot type;
run;


data &out_data._TIME; set result_out(where=(_replicate_=0) drop=_source_ _pat_rep);
	drop _replicate_; 
run;

ods listing;
ods select default;

title "observed versus expected donor availability";
title2 "with t_search=&tsearch"; 
title3 "&samplesize included patients (valid survival time and survival status)"; 
proc tabulate data=&out_data._TIME;
	var _M_Weight;
	class _donor _td_ ; 
	table _donor='observed' all='total', (_td_='expected' all='total')*_M_Weight=' '*(sum='freqency' pctsum='%'*f=6.2);
	format _donor _td_ _donf_.;
run;
title;

title "Kaplan-Meier estimate by groups according to known and expected donor availability";
title2 "with t_search=&tsearch";
title3 FINAL TSTAR= &_tstar_valid (only times are valid that are equal or higher than TSEARCH= &tsearch;
title4 "&samplesize included patients (valid survival time and survival status)"; 
ods output survivalplot=atrisk_data;
proc lifetest data=&out_data._TIME plot=(s %if &atrisk ne %then %do; (atrisk=&atrisk) %end; )
			timelist=&_tstar_valid outsurv=&out_data._SURV;* reduceout stderr;
	time &event_time*&event_status(0);
	weight _M_weight;
	strata _td_ ; 
run;

%if &atrisk ne %then %do; 
proc sgplot data=atrisk_data;* aspect=1;
	styleattrs datacontrastcolors=(blue red blue red) datalinepatterns=(solid solid) ;
	step x=time y=survival / group=Stratum;
	xaxistable atrisk / class=Stratum x=tatrisk colorgroup=Stratum;* nolabel; 
	yaxis grid min=0 max=1;
	xaxis values=(&atrisk)  label="Time" ;
	keylegend / location=inside position=topright across=1 noborder title=" ";
	format AtRisk 6.1;
run;
%end;



proc print data=_surv_prob_rep(where=(_replicate_=0)); 
	title "survival probabilites at time= &_tstar_valid";
	var _td_ timelist &event_time survival SDF_stderr SDF_LCL SDF_UCL;
	run;

proc print data=_surv_prob_test2 noobs label;
	title "Comparison of survival probabilites at time=&_tstar_valid, based on log-log transformation";
	title2 "two-sided significance level: &alpha";
	var timelist cHR CI_low_cHR CI_upp_cHR test prob
		%if %upcase(&boot_method)^=NO %then %do; boot %end; type; 
run;

title;
ods output close;
*proc datasets; 
*	delete _M_weight_all _data_all _s_bmt _scen_  _s_bmt_ ; 
run;
%mend AdjKM;
